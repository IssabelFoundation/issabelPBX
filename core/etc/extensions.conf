;--------------------------------------------------------------------------------;
; Do NOT edit this file as it is auto-generated by IssabelPBX. All modifications ;
; to this file must be done via the web gui. There are alternative files to make ;
; custom modifications, details at: http://issabel.org/configuration_files       ;
;--------------------------------------------------------------------------------;

;*******************************************************************************
; AUTO-GENERATED AND CUSOTM USER DIALPLAN INCLUDED HERE                        *
;*******************************************************************************

;--------------------------------------------------------------------------------;
; Customizations to this dialplan should be made in extensions_custom.conf
; See extensions_custom.conf.sample for an example.
;
; If you need to use [macro-dialout-trunk-predial-hook], [ext-did-custom], or 
; [from-internal-custom] for example, place these in this file or they will get overwritten.
;
; WARNING ABOUT: #include extensions_override_issabelpbx.conf
;
;  This include file is put first to allow the auto-generated dialplan in IssabelPBX
;  to be overwritten if necessary. Overriding auto-generated dialplan should be done
;  with extreme caution. In almost all cases any custom dialplan SHOULD be put in 
;  extensions_custom.conf which will not hurt a IssabelPBX generated dialplan. In some 
;  very rare and custom situations users may have a need to override what IssabelPBX 
;  automatically generates. If so anything in this file will do that.  If you come up 
;  with situations where you need to modify the existing dialplan or macros, put it 
;  here.
;
#include extensions_override_issabelpbx.conf
#include extensions_additional.conf
#include extensions_custom.conf
;--------------------------------------------------------------------------------;



;*******************************************************************************
; DIALPLAN OPEN TO THE PUBLIC, USING INBOUND DIDS AND SIMILAR                  *
;*******************************************************************************
;

;-------------------------------------------------------------------------------
; from-digital:
;
; Context to set for PRI's and equivalent
;
[from-digital]
include => from-pstn
;-------------------------------------------------------------------------------

;-------------------------------------------------------------------------------
; from-analog:
;
; Context to set for analog DAHDi cards and equivalent
;
[from-analog]
include => from-dahdi
;-------------------------------------------------------------------------------

;-------------------------------------------------------------------------------
; from-trunk:
;
; Context is really just an aliax of from-pstn
;
[from-trunk]
include => from-pstn
;-------------------------------------------------------------------------------

;-------------------------------------------------------------------------------
; from-pstn:
;
; Entry context for calls from the outside world to hit IssabelPBX
[from-pstn]
include => from-pstn-custom		; create this context in extensions_custom.conf to include customizations
include => ext-did
include => ext-did-post-custom
include => from-did-direct
include => ext-did-catchall		; THIS MUST COME AFTER ext-did
;-------------------------------------------------------------------------------

;-------------------------------------------------------------------------------
; from-pstn-e164-us:
;
; The context is designed for providers who send calls in e164 format and is
; biased towards NPA calls, callerid and dialing rules. It will do the following:
;
;  DIDs in an NPA e164 format of +1NXXNXXXXXX will be converted to 10 digit DIDs
;
;  DIDs in any other format will be delivered as they are, including e164 non NPA
;  DIDs which means they will need the full format including the + in the inbound
;  route.
;
;  CallerID(number) presented in e164 NPA format will be trimmed to a 10 digit CID
;
;  CallerID(number) presented in e164 non-NPA (country code other than 1) will be
;  reformated from: +<CountryCode><Number> to 011<CountryCode><Number>
;
[from-pstn-e164-us]
exten => _+1NXXNXXXXXX/_+1NXXNXXXXXX,1,Set(CALLERID(number)=${CALLERID(number):2})
exten => _+1NXXNXXXXXX/_NXXNXXXXXX,2,Goto(from-pstn,${EXTEN:2},1)
exten => _+1NXXNXXXXXX/_+NX.,1,Set(CALLERID(number)=011${CALLERID(number):1})
exten => _+1NXXNXXXXXX/_011NX.,n,Goto(from-pstn,${EXTEN:2},1)
exten => _+1NXXNXXXXXX,1,Goto(from-pstn,${EXTEN:2},1)
exten => _[0-9+]./_+1NXXNXXXXXX,1,Set(CALLERID(number)=${CALLERID(number):2})
exten => _[0-9+]./_1NXXNXXXXXX,1,Set(CALLERID(number)=${CALLERID(number):1})
exten => _[0-9+]./_NXXNXXXXXX,n,Goto(from-pstn,${EXTEN},1)
exten => _[0-9+]./_+NX.,1,Set(CALLERID(number)=011${CALLERID(number):1})
exten => _[0-9+]./_011NX.,n,Goto(from-pstn,${EXTEN},1)
exten => _[0-9+].,1,Goto(from-pstn,${EXTEN},1)
exten => s/_+1NXXNXXXXXX,1,Set(CALLERID(number)=${CALLERID(number):2})
exten => s/_NXXNXXXXXX,n,Goto(from-pstn,${EXTEN},1)
exten => s/_+NX.,1,Set(CALLERID(number)=011${CALLERID(number):1})
exten => s/_011NX.,n,Goto(from-pstn,${EXTEN},1)
exten => s,1,Goto(from-pstn,${EXTEN},1)
;-------------------------------------------------------------------------------

;-------------------------------------------------------------------------------
; from-pstn-to-did:
;
; The context is designed for providers who send the DID in the TO: SIP header
; only. The format of this header is:
;
; To: <sip:2125551212@172.31.74.25>
;
; So the DID must be extracted between the sip: and the @, which this does
;
[from-pstn-toheader]
exten => _.,1,Goto(from-pstn,${CUT(CUT(SIP_HEADER(To),@,1),:,2)},1)
;-------------------------------------------------------------------------------

;-------------------------------------------------------------------------------
; from-sip-external
;
; This context is the default SIP context unless otherwise changed in the SIP
; Settings module or other sip configuration locations. This context is hit by
; either anonymous SIP calls or mis-configured SIP trunks when the incoming call
; can not be matched with a SIP section.
;
[from-sip-external]
exten => _.,1,NoOp(Received incoming SIP connection from unknown peer to ${EXTEN})
exten => _.,n,Set(DID=${IF($["${EXTEN:1:2}"=""]?s:${EXTEN})})
exten => _.,n,Goto(s,1)
exten => s,1,GotoIf($["${ALLOW_SIP_ANON}"="yes"]?checklang:noanonymous)
exten => s,n(checklang),GotoIf($["${SIPLANG}"!=""]?setlanguage:from-trunk,${DID},1)
exten => s,n(setlanguage),Set(CHANNEL(language)=${SIPLANG})
exten => s,n,Goto(from-trunk,${DID},1)
exten => s,n(noanonymous),Set(TIMEOUT(absolute)=15)
exten => s,n,Log(WARNING,"Rejecting unknown SIP connection from ${CHANNEL(recvip)}")
exten => s,n,Answer
exten => s,n,Wait(2)
exten => s,n,Playback(ss-noservice)
exten => s,n,Playtones(congestion)
exten => s,n,Congestion(5)
exten => h,1,Hangup
exten => i,1,Hangup
exten => t,1,Hangup
;-------------------------------------------------------------------------------



;*******************************************************************************
; INTERNAL DIALPLAN, NOT OPEN TO THE PUBLIC WORLD                              *
;*******************************************************************************
;

;-------------------------------------------------------------------------------
; from-internal:
;
; Internal dialplan that most internal phones have access to
; 
[from-internal]
include => from-internal-noxfer
include => from-internal-xfer
include => bad-number ; auto-generated
;-------------------------------------------------------------------------------

;-------------------------------------------------------------------------------
; from-internal-noxfer:
;
; Place to put internal dialplan that should not be accessible during a blind
; transfer, this context will not be visible during such.
; 
[from-internal-noxfer]
include => from-internal-noxfer-custom
include => from-internal-noxfer-additional ; auto-generated
;-------------------------------------------------------------------------------

;-------------------------------------------------------------------------------
; from-internal-xfer:
;
; Place to put most internal dialplan, will be visible during normal calls and
; blind transfers.
; 
[from-internal-xfer]
include => from-internal-custom
include => from-internal-additional ; auto-generated
exten => s,1,Macro(hangupcall)
exten => h,1,Macro(hangupcall)
;-------------------------------------------------------------------------------



;*******************************************************************************
; INTERNAL MACROS & SPECIAL CONTEXTS                                           *
;*******************************************************************************
;

;-------------------------------------------------------------------------------
; from-did-direct:
;
; forces ext-findmefollow to take precedence over ext-local. Also exposed to
; the public side to allow an extension number to be used as an external DID
; without requiring inbound routes to be created, common in many PRI installations
; where the last 4 digits are used as the extnension and DIDs are delivered in
; 4 digit formats.
;
[from-did-direct]
include => ext-findmefollow
include => ext-local
;-------------------------------------------------------------------------------

;-------------------------------------------------------------------------------
; macro-dial:
;
; Rings one or more extensions.  Handles things like call forwarding and DND
; We don't call dial directly for anything internal anymore.
; ARGS: $TIMER, $OPTIONS, $EXT1, $EXT2, $EXT3, ...
; Use a Macro call such as the following: 
;
;  Macro(dial,$DIAL_TIMER,$DIAL_OPTIONS,$EXT1,$EXT2,$EXT3,...)
;
[macro-dial]
exten => s,1,GotoIf($["${MOHCLASS}" = ""]?dial)
exten => s,n,Set(CHANNEL(musicclass)=${MOHCLASS})
exten => s,n(dial),ExecIf($["${DIRECTION}" = "INBOUND"]?Set(DIAL_OPTIONS=${STRREPLACE(DIAL_OPTIONS,T)}))
exten => s,n,AGI(dialparties.agi)
exten => s,n,NoOp(Returned from dialparties with no extensions to call and DIALSTATUS: ${DIALSTATUS})

exten => s,n+2(normdial),Dial(${ds}) ; dialparties will set the priority to 10 if $ds is not null
exten => s,n,Set(DIALSTATUS=${IF($["${DIALSTATUS_CW}"!="" ]?${DIALSTATUS_CW}:${DIALSTATUS})})
exten => s,n,GosubIf($[("${SCREEN}" != "" & ("${DIALSTATUS}" = "TORTURE" | "${DIALSTATUS}" = "DONTCALL"))  | "${DIALSTATUS}" = "ANSWER"]?${DIALSTATUS},1)

exten => s,20(huntdial),NoOp(Returned from dialparties with hunt groups to dial )
exten => s,n,Set(HuntLoop=0)
exten => s,n(a22),GotoIf($[${HuntMembers} >= 1]?a30)  ; if this is from rg-group, don't strip prefix
exten => s,n,NoOp(Returning there are no members left in the hunt group to ring)

; dialparties.agi has setup the dialstring for each hunt member in a variable labeled HuntMember0, HuntMember1 etc for each iteration
; and The total number in HuntMembers. So for each iteration, we will update the CALLTRACE Data.
;
exten => s,n+2(a30),Set(HuntMember=HuntMember${HuntLoop})
exten => s,n,GotoIf($[$["${CALLTRACE_HUNT}" != "" ] & $[$["${RingGroupMethod}" = "hunt" ] | $["${RingGroupMethod}" = "firstavailable"] | $["${RingGroupMethod}" = "firstnotonphone"]]]?a32:a35)

exten => s,n(a32),Set(CT_EXTEN=${CUT(FILTERED_DIAL,,$[${HuntLoop} + 1])})
exten => s,n,Set(DB(CALLTRACE/${CT_EXTEN})=${CALLTRACE_HUNT})
exten => s,n,Goto(s,a42)

;Set Call Trace for each hunt member we are going to call "Memory groups have multiple members to set CALL TRACE For" hence the loop
;
exten => s,n(a35),GotoIf($[$["${CALLTRACE_HUNT}" != "" ] & $["${RingGroupMethod}" = "memoryhunt" ]]?a36:a50)  
exten => s,n(a36),Set(CTLoop=0)
exten => s,n(a37),GotoIf($[${CTLoop} > ${HuntLoop}]?a42)  ; if this is from rg-group, don't strip prefix
exten => s,n,Set(CT_EXTEN=${CUT(FILTERED_DIAL,,$[${CTLoop} + 1])})
exten => s,n,Set(DB(CALLTRACE/${CT_EXTEN})=${CALLTRACE_HUNT})
exten => s,n,Set(CTLoop=$[1 + ${CTLoop}])
exten => s,n,Goto(s,a37)
        
exten => s,n(a42),Dial(${${HuntMember}}${ds})
exten => s,n,GotoIf($["${DIALSTATUS}" = "ANSWER"]?ANSWER,1)
exten => s,n,Set(HuntLoop=$[1 + ${HuntLoop}])
exten => s,n,GotoIf($[$[$["foo${RingGroupMethod}" != "foofirstavailable"] & $["foo${RingGroupMethod}" != "foofirstnotonphone"]] | $["foo${DialStatus}" = "fooBUSY"]]?a46)
exten => s,n,Set(HuntMembers=0)
exten => s,n(a46),Set(HuntMembers=$[${HuntMembers} - 1])
exten => s,n,Goto(s,a22)

exten => s,n(a50),Noop(Deleting: CALLTRACE/${CT_EXTEN} ${DB_DELETE(CALLTRACE/${CT_EXTEN})})
exten => s,n,Goto(s,a42)

; For call screening
exten => NOANSWER,1,Macro(vm,${SCREEN_EXTEN},BUSY,${IVR_RETVM})
exten => NOANSWER,n,GotoIf($["${IVR_RETVM}" != "RETURN" | "${IVR_CONTEXT}" = ""]?bye)
exten => NOANSWER,n,Return
exten => NOANSWER,n(bye),Macro(hangupcall)
exten => TORTURE,1,Goto(app-blackhole,musiconhold,1)
exten => TORTURE,n,Macro(hangupcall)
exten => DONTCALL,1,Answer
exten => DONTCALL,n,Wait(1)
exten => DONTCALL,n,Zapateller()
exten => DONTCALL,n,Playback(ss-noservice)
exten => DONTCALL,n,Macro(hangupcall)
exten => ANSWER,1,Noop(Call successfully answered - Hanging up now)
exten => ANSWER,n,Macro(hangupcall,)

; make sure hungup calls go here so that proper cleanup occurs from call confirmed calls and the like
;
exten => h,1,Macro(hangupcall)
;-------------------------------------------------------------------------------

;-------------------------------------------------------------------------------
; macro-get-vmcontext:
;
; returns the user's voicemail context
;
[macro-get-vmcontext]
exten => s,1,Set(VMCONTEXT=${DB(AMPUSER/${ARG1}/voicemail)})
exten => s,2,GotoIf($["foo${VMCONTEXT}" = "foo"]?200:300)
exten => s,200,Set(VMCONTEXT=default)
exten => s,300,NoOp()
;-------------------------------------------------------------------------------

;-------------------------------------------------------------------------------
; macro-outisbusy:
;
; called if all trunks are busy.  This macro is overwridden by the
; Outbound Route Messages module if installed and configured to provide
; better messages or choices of tones.
;
[macro-outisbusy]
exten => s,1,Progress
exten => s,n,Playback(all-circuits-busy-now,noanswer)
exten => s,n,Playback(pls-try-call-later,noanswer)
exten => s,n,Macro(hangupcall)
;-------------------------------------------------------------------------------

;-------------------------------------------------------------------------------
; macro-dialout-trunk-predial-hook:
;
; this macro intentionally left blank so it may be safely overwritten for any custom
; requirements that an installation may have.
;
; the macro is called by macro-dialout-trunk just prior to making a Dial() attempt
; to a trunk.
;
; MACRO RETURN CODE: ${PREDIAL_HOOK_RET}
;                    if set to "BYPASS" then this trunk will be skipped
;
;
[macro-dialout-trunk-predial-hook]
exten => s,1,MacroExit()
;-------------------------------------------------------------------------------

;-------------------------------------------------------------------------------
; macro-user-logon:
;
; Used to log a user onto an adhoc device. Most of the work is done by
; user_login_out.agi AGI script
;
[macro-user-logon]
exten => s,1,Set(DEVICETYPE=${DB(DEVICE/${CALLERID(number)}/type)})
exten => s,n,Answer()
exten => s,n,Wait(1)
exten => s,n,GotoIf($["${DEVICETYPE}" = "fixed"]?s-FIXED,1)
; get user's extension
;
exten => s,n,Set(AMPUSER=${ARG1})
exten => s,n,GotoIf($["${AMPUSER}" != ""]?gotpass)
exten => s,n(playagain),Read(AMPUSER,please-enter-your-extension-then-press-pound,,,4)
; get user's password and authenticate
;
exten => s,n,GotoIf($["${AMPUSER}" = ""]?s-MAXATTEMPTS,1)
exten => s,n(gotpass),GotoIf($["${DB_EXISTS(AMPUSER/${AMPUSER}/password)}" = "0"]?s-NOUSER,1)
exten => s,n,Set(AMPUSERPASS=${DB_RESULT})
exten => s,n,GotoIf($[${LEN(${AMPUSERPASS})} = 0]?s-NOPASSWORD,1)
; do not continue if the user has already logged onto this device
;
exten => s,n,Set(DEVICEUSER=${DB(DEVICE/${CALLERID(number)}/user)})
exten => s,n,GotoIf($["${DEVICEUSER}" = "${AMPUSER}"]?s-ALREADYLOGGEDON,1)
exten => s,n,Authenticate(${AMPUSERPASS})
exten => s,n,AGI(user_login_out.agi,login,${CALLERID(number)},${AMPUSER})
exten => s,n,Playback(agent-loginok)

exten => s-FIXED,1,NoOp(Device is FIXED and cannot be logged into)
exten => s-FIXED,n,Playback(ha/phone)
exten => s-FIXED,n,SayDigits(${CALLERID(number)})
exten => s-FIXED,n,Playback(is-curntly-unavail&vm-goodbye)
exten => s-FIXED,n,Hangup ;TODO should play msg indicated device cannot be logged into 

exten => s-ALREADYLOGGEDON,1,NoOp(This device has already been logged into by this user)
exten => s-ALREADYLOGGEDON,n,Playback(vm-goodbye)
exten => s-ALREADYLOGGEDON,n,Hangup ;TODO should play msg indicated device is already logged into 

exten => s-NOPASSWORD,1,NoOp(This extension does not exist or no password is set)
exten => s-NOPASSWORD,n,Playback(pbx-invalid)
exten => s-NOPASSWORD,n,Goto(s,playagain)

exten => s-MAXATTEMPTS,1,NoOp(Too many login attempts)
exten => s-MAXATTEMPTS,n,Playback(vm-goodbye)
exten => s-MAXATTEMPTS,n,Hangup

exten => s-NOUSER,1,NoOp(Invalid extension ${AMPUSER} entered)
exten => s-NOUSER,n,Playback(pbx-invalid)
exten => s-NOUSER,n,Goto(s,playagain)
;-------------------------------------------------------------------------------

;-------------------------------------------------------------------------------
; macro-user-logoff:
;
; Used to log a user off of an adhoc device. Most of the work is done by
; user_login_out.agi AGI script
;
[macro-user-logoff]
exten => s,1,Set(DEVICETYPE=${DB(DEVICE/${CALLERID(number)}/type)})
exten => s,n,GotoIf($["${DEVICETYPE}" = "fixed"]?s-FIXED,1)
exten => s,n,AGI(user_login_out.agi,logout,${CALLERID(number)})
exten => s,n(done),Playback(agent-loggedoff)

exten => s-FIXED,1,NoOp(Device is FIXED and cannot be logged out of)
exten => s-FIXED,n,Playback(an-error-has-occured&vm-goodbye)
exten => s-FIXED,n,Hangup ;TODO should play msg indicated device cannot be logged into 
;-------------------------------------------------------------------------------

;-------------------------------------------------------------------------------
; default
;
; IssabelPBX does not use the default context. This context is used by asterisk when
; it has no other information provided and needs to deliver a call. Hitting this means
; there has been some sort of configuration error, or a potential bug somehwere.
; This context can be reached from either internal or external sources.
; 
[default]
include => ext-local
exten => s,1,Playback(vm-goodbye)
exten => s,n,Noop(ERROR: IssabelPBX Does not use the [default] context, confguration error)
exten => s,n,Macro(hangupcall)
;-------------------------------------------------------------------------------



;*******************************************************************************
; DEPRECATED DIALPLAN - THESE WILL BE REMOVED, NOT USED BY ISSABELPBX             *
;*******************************************************************************
;

;-------------------------------------------------------------------------------
; macro-fixcid: [DEPRECATED]
;
; For some reason, if I don't run setCIDname, CALLERID(name) will be blank in my AGI
;
[macro-fixcid]
exten => s,1,Set(CALLERID(name)=${CALLERID(name)})
;-------------------------------------------------------------------------------


;-------------------------------------------------------------------------------
; macro-sayXXXX: [DEPRECATED]
;
; Text-To-Speech related macros
; These all follow common actions.  First try to playback a file "tts/custom-md5" 
; where "md5" is the md5() of whatever is going to be played. If that doesn't exist,
; try to playback using macro-tts-sayXXXXX (where XXXXX is text/digits/etc, same as
; the macro below). If that macro exits with MACRO_OFFSET=100, then it's done, 
; otherwise, fallback to the default asterisk method. 
;

;-------------------------------------------------------------------------------
; macro-saytext: [DEPRECATED]
;
; say text is purely for text-to-speech, there is no fallback
;
[macro-saytext]
exten => s,1,Noop(Trying custom SayText playback for "${ARG1}")
exten => s,n,Playback(tts/custom-${MD5(${ARG1})})
exten => s,n,GotoIf($["${PLAYBACKSTATUS}"="SUCCESS"]?done)
; call tts-saytext. This should set MACRO_OFFSET=101 if it was successful
exten => s,n(tts),Macro(tts-saytext,${ARG1},${ARG2},${ARG3})
exten => s,n,Noop(No text-to-speech handler for SayText, cannot say "${ARG1}")
exten => s,n,Goto(done)
exten => s,tts+101,Noop(tts handled saytext)
;-------------------------------------------------------------------------------

;-------------------------------------------------------------------------------
; macro-sayname: [DEPRECATED]
;
; say name is for saying names typically, but fallsback to using SayAlpha
; (saying the word letter-by-letter)
;
[macro-sayname]
exten => s,1,Noop(Trying custom SayName playback for "${ARG1}")
exten => s,n,Playback(tts/custom-${MD5(${ARG1})})
exten => s,n,GotoIf($["${PLAYBACKSTATUS}"="SUCCESS"]?done)
; call tts-sayalpha. This should set MACRO_OFFSET=101 if it was successful
exten => s,n(tts),Macro(tts-sayalpha,${ARG1},${ARG2},${ARG3})
exten => s,n,SayAlpha(${ARG1})
exten => s,n,Goto(done)
exten => s,tts+101,Noop(tts handled sayname)
;-------------------------------------------------------------------------------

;-------------------------------------------------------------------------------
; macro-saynumber: [DEPRECATED]
;
; Say number is for saying numbers (eg "one thousand forty six") 
;
[macro-saynumber]
exten => s,1,Noop(Trying custom SayNumber playback for "${ARG1}")
exten => s,n,Playback(tts/custom-${MD5(${ARG1})})
exten => s,n,GotoIf($["${PLAYBACKSTATUS}"="SUCCESS"]?done)
; call tts-saynumber. This should set MACRO_OFFSET=101 if it was successful
exten => s,n(tts),Macro(tts-saynumber,${ARG1},${ARG2},${ARG3})
exten => s,n,SayNumber(${ARG1})
exten => s,n,Goto(done)
exten => s,tts+101,Noop(tts handled saynumber)
;-------------------------------------------------------------------------------

;-------------------------------------------------------------------------------
; macro-saydigits: [DEPRECATED]
;
; Say digits is for saying digits one-by-one (eg, "one zero four six")
;
[macro-saydigits]
exten => s,1,Noop(Trying custom SayDigits playback for "${ARG1}")
exten => s,n,Playback(tts/custom-${MD5(${ARG1})})
exten => s,n,GotoIf($["${PLAYBACKSTATUS}"="SUCCESS"]?done)
; call tts-saydigits. This should set MACRO_OFFSET=101 if it was successful
exten => s,n(tts),Macro(tts-saydigits,${ARG1},${ARG2},${ARG3})
exten => s,n,SayDigits(${ARG1})
exten => s,n,Goto(done)
;-------------------------------------------------------------------------------
